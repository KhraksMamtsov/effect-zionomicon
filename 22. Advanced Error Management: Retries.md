# 22. Advanced Error Management: Retries
## 22.1 Limitations of Traditional Retry Operators
```ts
// https://effect.website/play/#f62fd85b5a43

function retryWithDelay<A, E, R>(options: {
  n: number
  effect: Effect<A, E, R>
  duration: Duration
}): Effect<A, E, R> {
  const { n, effect, duration } = options
  if (n <= 0) {
    return effect
  } else {
    return Effect.catchAll(effect, () =>
      retryWithDelay({
        n: n - 1,
        duration,
        effect
      })).pipe(
        Effect.delay(duration)
      )
  }
}
```

## 22.2 Retrying and Repeating with ZIO
```ts
// Schedule.ts
interface Schedule<out Out, in In = unknown, out R = never> {}
```
```ts
// https://effect.website/play/#73f1267593df
const delayN = (n: number, duration: Duration) =>
  Schedule.intersect(
    Schedule.recurs(n),
    Schedule.spaced(duration)
  )
```
```ts
// Effect.ts
declare const repeat: <A, E, R, B, R1>(
    self: Effect<A, E, R>, 
    schedule: Schedule<B, A, R1>
) => Effect<B, E, R | R1>
declare const repeat: <A, E, R, B, R1>(
    self: Effect<A, E, R>,
    policy: Schedule<B, E, R1>
) => Effect<A, E, R1 | R>
```
## 22.3 Common Schedules
### 22.3.1 Schedules for Recurrences
```ts
// Schedule.ts

/**
 * A schedule spanning all time, which can be stepped only the specified
 * number of times before it terminates.
 */
declare const recurs: (n: number) => Schedule<number>
```
### 22.3.2 Schedules for Delays
```ts
// Schedule.ts

/**
 * Returns a schedule that recurs continuously, each repetition spaced the
 * specified duration from the last run.
 */
declare const spaced: (duration: Duration) => Schedule<number>

/**
 * A schedule that recurs on a fixed interval. Returns the number of
 * repetitions of the schedule so far.
 *
 * If the action run between updates takes longer than the interval, then the
 * action will be run immediately, but re-runs will not "pile up".
 *
 * ```
 * |-----interval-----|-----interval-----|-----interval-----|
 * |---------action--------||action|-----|action|-----------|
 * ```
 */
declare const fixed: (duration: Duration) => Schedule<number>

/**
 * A schedule that divides the timeline to `interval`-long windows, and sleeps
 * until the nearest window boundary every time it recurs. *
 * For example, `windowed(Duration.seconds(10))` would produce a schedule as
 * follows:
 *
 * ```
 *      10s        10s        10s       10s
 * |----------|----------|----------|----------|
 * |action------|sleep---|act|-sleep|action----|
 * ```
 */
declare const windowed:  (duration: Duration) => Schedule<number>

/**
 * A schedule that always recurs, but will repeat on a linear time interval,
 * given by `base * n` where `n` is the number of repetitions so far. Returns
 * the current duration between recurrences.
 */
declare const linear:  (duration: Duration) => Schedule<Duration>

/**
 * A schedule that always recurs, but will wait a certain amount between
 * repetitions, given by `base * factor.pow(n)`, where `n` is the number of
 * repetitions so far. Returns the current duration between recurrences.
 */
declare const exponential: (
  base: Duration,
  factor?: number
) => Schedule<Duration>

/**
 * A schedule that always recurs, increasing delays by summing the preceding
 * two delays (similar to the fibonacci sequence). Returns the current
 * duration between recurrences.
 */
declare const fibonacci: (one: Duration) => Schedule<Duration>


/**
 * A schedule that recurs once with the specified delay.
 */
declare const fromDelay: (delay: Duration) => Schedule<Duration>

/**
 * A schedule that recurs once for each of the specified durations, delaying
 * each time for the length of the specified duration. Returns the length of
 * the current duration between recurrences.
 */
declare const fromDelays: (
  delay: Duration,
  ...delays: Array<Duration>
) => Schedule<Duration>
```

### 22.3.3 Schedules for Conditions
```ts
// Schedule.ts

/**
 * A schedule that recurs for as long as the predicate evaluates to true.
 */
declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>

/**
 * A schedule that recurs for as long as the effectful predicate evaluates to
 * true.
 */
declare const recurWhileEffect: <A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<A, A, R>

/**
 * A schedule that recurs for until the predicate evaluates to true.
 */
declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>

/**
 * A schedule that recurs for until the predicate evaluates to true.
 */
declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>

/**
 * A schedule that recurs for until the predicate evaluates to true.
 */
declare const recurUntilEffect: <A, R>(f: (a: A) => Effect<boolean, never, R>) => Schedule<A, A, R>
```