# 7. Parallelism and Concurrency: Fiber Supervision in Depth
## 7.1 Fork/Join Identity Law
```ts
declare const effect: Effect<any, any, any>

Effect.fork(effect).pipe(Effect.flatMap((fiber) => Fiber.join(fiber))) === effect
```
## 7.2 Structured Concurrency
```ts
// https://effect.website/play/#4fb1c7e35c9c

const child = (name: string) =>
  Effect.log(`Child fiber ${name} is running...`).pipe(
    Effect.flatMap((_) => Effect.sleep("5 seconds")),
    Effect.onInterrupt(() => Effect.log(`Child fiber ${name} is interrupted!`))
  )

const parent = Effect.gen(function*() {
  yield* Effect.log("Parent fiber beginning execution...")
  yield* Effect.fork(child("foo"))
  yield* Effect.fork(child("bar"))
  yield* Effect.log("Parent fiber ending execution...")
}).pipe(
  Effect.onExit((_) => Effect.log("Parent fiber exited!"))
)

const run = Effect.gen(function*() {
  yield* Effect.log("Main fiber beginning execution...")
  yield* Effect.fork(parent)
  yield* Effect.log("Main fiber ending execution...")
})
// [14:35:04.409] INFO (#0): Main fiber beginning execution...
// [14:35:04.411] INFO (#0): Main fiber ending execution...
// [14:35:04.412] INFO (#8): Parent fiber beginning execution...
// [14:35:04.412] INFO (#8): Parent fiber ending execution...
// [14:35:04.413] INFO (#8): Parent fiber exited!
```
## 7.3.1 Forking in the Global Scope
```ts
declare const forkDaemon: <A, E, R>(
    self: Effect<A, E, R>
) => Effect<Fiber.RuntimeFiber<A, E>, never, R>
```
## 7.3.2 Forking in the Current Local Scope
```ts
declare const forkScoped: <A, E, R>(
    self: Effect<A, E, R>
) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope | R>
```
```ts
// Effect.ts
declare const scoped: <A, E, R>(
    effect: Effect<A, E, R>
) => Effect<A, E, Exclude<R, Scope>>
```
```ts
// https://effect.website/play/#b47a5e9d875f

const task = (name: string) =>
  Effect.log(`Fiber ${name} is running...`).pipe(
    Effect.schedule(Schedule.fixed("1 second")),
    Effect.onInterrupt(() => Effect.log(`Fiber ${name} interrupted!`)),
    Effect.ignore
  )

const run = Effect.gen(function*() {
  yield* Effect.scoped(Effect.gen(function*() {
    yield* Effect.forkScoped(task("A"))
    yield* Effect.log("Fiber A forked!")
    yield* Effect.sleep("5 seconds")
  }))
  
  yield* Effect.log("Main fiber after closing the scope.")
  yield* Effect.log("Sleeping for 3 seconds before exiting.")
  yield* Effect.sleep("3 seconds")
  yield* Effect.log("Exiting main fiber.")
})
// [14:46:36.996] INFO (#0): Fiber A forked!
// [14:46:37.999] INFO (#8): Fiber A is running...
// [14:46:39.003] INFO (#8): Fiber A is running...
// [14:46:40.005] INFO (#8): Fiber A is running...
// [14:46:41.004] INFO (#8): Fiber A is running...
// [14:46:42.006] INFO (#8): Fiber A interrupted!
// [14:46:42.006] INFO (#0): Main fiber after closing the scope.
// [14:46:42.007] INFO (#0): Sleeping for 3 seconds before exiting.
// [14:46:45.014] INFO (#0): Exiting main fiber.
```

```ts
// https://effect.website/play/#53c29609263b


const task = (name: string) =>
  Effect.log(`Fiber ${name} is running...`).pipe(
    Effect.schedule(Schedule.fixed("1 second")),
    Effect.onInterrupt(() => Effect.log(`Fiber ${name} interrupted!`)),
    Effect.ignore
  )
const taskA = Effect.gen(function*() {
  const fiberB = yield* Effect.fork(task("B"))
  yield* Effect.log("Fiber B forked!")
  yield* Effect.log("Waiting 3 seconds after forking task B")
  yield* Effect.sleep("3 seconds")
  const fiberC = yield* Effect.fork(task("C"))
  yield* Effect.log("Fiber C forked!")
  yield* Effect.log("Waiting 5 seconds after forking task C")
  yield* Effect.sleep("5 seconds")
  const fiberD = yield* Effect.forkScoped(task("D"))
  yield* Effect.log("Fiber D forkScoped!")
  yield* Effect.log("Waiting 7 seconds after forking task D")
  yield* Effect.sleep("7 seconds")
}).pipe(Effect.onExit((e) => Effect.log("Fiber A extited with exit status: " + e._tag)))

const run = Effect.gen(function*() {
  yield* Effect.scoped(Effect.gen(function*() {
    yield* Effect.fork(taskA)
    yield* Effect.log("Fiber A forked!")
    yield* Effect.sleep("5 seconds")
    const fiberE = yield* Effect.fork(task("E"))
    yield* Effect.log("Fiber E forked!")
    yield* Effect.log("Waiting 9 seconds after forking task E")
    yield* Effect.sleep("9 seconds")
  })).pipe(Effect.onExit((e) => Effect.log("Scoped section exited with exit status: " + e._tag)))

  yield* Effect.log("Main fiber after closing the scope.")
  yield* task("F").pipe(
    Effect.fork,
    Effect.flatMap((fiberF) => fiberF.pipe(Fiber.interrupt, Effect.delay("11 seconds")))
  )
})

// [14:57:12.928] INFO (#0): Fiber A forked!
// [14:57:12.930] INFO (#8): Fiber B forked!
// [14:57:12.931] INFO (#8): Waiting 3 seconds after forking task B
// [14:57:13.940] INFO (#9): Fiber B is running...
// [14:57:14.938] INFO (#9): Fiber B is running...
// [14:57:15.936] INFO (#8): Fiber C forked!
// [14:57:15.937] INFO (#8): Waiting 5 seconds after forking task C
// [14:57:15.937] INFO (#9): Fiber B is running...
// [14:57:16.937] INFO (#9): Fiber B is running...
// [14:57:16.944] INFO (#10): Fiber C is running...
// [14:57:17.939] INFO (#0): Fiber E forked!
// [14:57:17.939] INFO (#0): Waiting 9 seconds after forking task E
// [14:57:17.940] INFO (#9): Fiber B is running...
// [14:57:17.946] INFO (#10): Fiber C is running...
// [14:57:18.937] INFO (#9): Fiber B is running...
// [14:57:18.943] INFO (#10): Fiber C is running...
// [14:57:18.949] INFO (#11): Fiber E is running...
// [14:57:19.944] INFO (#9): Fiber B is running...
// [14:57:19.945] INFO (#10): Fiber C is running...
// [14:57:19.945] INFO (#11): Fiber E is running...
// [14:57:20.937] INFO (#9): Fiber B is running...
// [14:57:20.944] INFO (#8): Fiber D forkScoped!
// [14:57:20.944] INFO (#8): Waiting 7 seconds after forking task D
// [14:57:20.945] INFO (#10): Fiber C is running...
// [14:57:20.951] INFO (#11): Fiber E is running...
// [14:57:21.945] INFO (#9): Fiber B is running...
// [14:57:21.946] INFO (#10): Fiber C is running...
// [14:57:21.947] INFO (#11): Fiber E is running...
// [14:57:21.952] INFO (#12): Fiber D is running...
// [14:57:22.937] INFO (#9): Fiber B is running...
// [14:57:22.943] INFO (#10): Fiber C is running...
// [14:57:22.948] INFO (#11): Fiber E is running...
// [14:57:22.953] INFO (#12): Fiber D is running...
// [14:57:23.937] INFO (#9): Fiber B is running...
// [14:57:23.943] INFO (#10): Fiber C is running...
// [14:57:23.949] INFO (#11): Fiber E is running...
// [14:57:23.950] INFO (#12): Fiber D is running...
// [14:57:24.936] INFO (#9): Fiber B is running...
// [14:57:24.943] INFO (#10): Fiber C is running...
// [14:57:24.948] INFO (#11): Fiber E is running...
// [14:57:24.953] INFO (#12): Fiber D is running...
// [14:57:25.938] INFO (#9): Fiber B is running...
// [14:57:25.944] INFO (#10): Fiber C is running...
// [14:57:25.949] INFO (#11): Fiber E is running...
// [14:57:25.950] INFO (#12): Fiber D is running...
// [14:57:26.937] INFO (#9): Fiber B is running...
// [14:57:26.944] INFO (#10): Fiber C is running...
// [14:57:26.945] INFO (#12): Fiber D interrupted!
// [14:57:26.947] INFO (#0): Scoped section exited with exit status: Success
// [14:57:26.947] INFO (#0): Main fiber after closing the scope.
// [14:57:26.947] INFO (#11): Fiber E is running...
// [14:57:27.936] INFO (#9): Fiber B is running...
// [14:57:27.943] INFO (#10): Fiber C is running...
// [14:57:27.948] INFO (#11): Fiber E is running...
// [14:57:27.953] INFO (#8): Fiber A extited with exit status: Success
// [14:57:27.954] INFO (#9): Fiber B interrupted!
// [14:57:27.955] INFO (#10): Fiber C interrupted!
// [14:57:27.955] INFO (#13): Fiber F is running...
// [14:57:28.946] INFO (#11): Fiber E is running...
// [14:57:28.954] INFO (#13): Fiber F is running...
// [14:57:29.946] INFO (#11): Fiber E is running...
// [14:57:29.953] INFO (#13): Fiber F is running...
// [14:57:30.946] INFO (#11): Fiber E is running...
// [14:57:30.954] INFO (#13): Fiber F is running...
// [14:57:31.946] INFO (#11): Fiber E is running...
// [14:57:31.952] INFO (#13): Fiber F is running...
// [14:57:32.946] INFO (#11): Fiber E is running...
// [14:57:32.953] INFO (#13): Fiber F is running...
// [14:57:33.946] INFO (#11): Fiber E is running...
// [14:57:33.954] INFO (#13): Fiber F is running...
// [14:57:34.947] INFO (#11): Fiber E is running...
// [14:57:34.953] INFO (#13): Fiber F is running...
// [14:57:35.947] INFO (#11): Fiber E is running...
// [14:57:35.953] INFO (#13): Fiber F is running...
// [14:57:36.947] INFO (#11): Fiber E is running...
// [14:57:36.953] INFO (#13): Fiber F is running...
// [14:57:37.946] INFO (#11): Fiber E is running...
// [14:57:37.955] INFO (#13): Fiber F interrupted!
// [14:57:37.970] INFO (#11): Fiber E interrupted!
```

## 7.3.3 Forking in a Specific Scope
```ts
// https://effect.website/play/#b1181352461e

const run = Effect.scoped(Effect.gen(function*() {
  const outerScope = yield* Effect.scope
  yield* Effect.scoped(Effect.gen(function*() {
    yield* Effect.log("Task is still active...").pipe(
      Effect.repeat(Schedule.fixed("1 second")),
      Effect.forkIn(outerScope)
    )
    yield* Effect.sleep("3 seconds")
    yield* Effect.log("Closing the innermost scope")
  }))
  yield* Effect.sleep("5 seconds")
  yield* Effect.log("Closing the outermost scope.")
}))

// [15:02:37.763] INFO (#8): Task is still active...
// [15:02:38.767] INFO (#8): Task is still active...
// [15:02:39.772] INFO (#8): Task is still active...
// [15:02:40.772] INFO (#0): Closing the innermost scope
// [15:02:40.773] INFO (#8): Task is still active...
// [15:02:41.772] INFO (#8): Task is still active...
// [15:02:42.771] INFO (#8): Task is still active...
// [15:02:43.770] INFO (#8): Task is still active...
// [15:02:44.771] INFO (#8): Task is still active...
// [15:02:45.770] INFO (#8): Task is still active...
// [15:02:45.782] INFO (#0): Closing the outermost scope.
```