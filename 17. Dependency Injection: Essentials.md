# 17. Dependency Injection: Essentials

```ts
type Effect<A, E, R> = (context: Context<R>) => A | E
```
```ts
declare const workflow1: Effect<void, Error, Request>
declare const workflow2: Effect<void, Error, Scope>

const workflow3: Effect<void, Error, Request | Scope> = Effect.zipRight(workflow1, workflow2)
```
```ts
declare const effect1: Effect<void, Error, Scope>
const effect2: Effect<void, Error, Scope | never> = effect1
const effect3: Effect<void, Error, Scope> = effect2
```
```ts
declare const effect4: Effect<void, Error, Scope | Request>
const effect5: Effect<void, Error, Request | Scope> = effect5
```
```ts
declare const effect6: Effect<void, Error, Scope>
const effect7: Effect<void, Error, Scope | Scope> = effect6
const effect8: Effect<void, Error, Scope> = effect7
```
## 17.2 Fundamental Operators for Working with the Environment
```ts
// Effect.ts
declare const context: <R>() => Effect<Context<R>, never, R>
```
```ts
// Effect.service was removed, because Tag became a subtype of Effect.
interface Tag<in out Id, in out Value> extends Effect<Value, never, Id> {}
```
```ts
Effect.flatMap(Scope.Scope, scope => Scope.addFinalizer(scope, Effect.void))
```
## 17.4 The Onion Architecture
```ts
// https://effect.website/play/#cdc5775ff892
import { Data, Effect, Chunk } from 'effect'

class Issue extends Data.Class {}
class Comment extends Issue {
  constructor(
    public readonly text: string
  ) {
    super()
  }
}

interface BussinessLogic {
  run: Effect.Effect<void>
}

interface GitHub {
  getIssues: (organization: string) => Effect.Effect<Chunk.Chunk<Issue>>
  postComment: (issue: Issue, comment: Comment) => Effect.Effect<void>
}

interface Http {
  get: (url: string) => Effect.Effect<Chunk.Chunk<number>>
  post: (url: string, body: Chunk.Chunk<number>) => Effect.Effect<Chunk.Chunk<number>>
}

const BussinessLogicLive = (github: GitHub): BussinessLogic => ({
  run: Effect.gen(function*() {
    const issues = yield* github.getIssues("effect")
    const comment = new Comment("I am working on this!")
    yield* Effect.orDie(Chunk.head(issues))
      .pipe(Effect.flatMap((issue) => github.postComment(issue, comment)))
  })
})

const GitHubLive = (http: Http): GitHub => ({
  getIssues: () => "implementation" as any,
  postComment: () => "implementation" as any,
})

const HttpLive = (): Http => ({
  get: () => "implementation" as any,
  post: () => "implementation" as any,
})

const http = HttpLive()
const github = GitHubLive(http)
const bll = BussinessLogicLive(github)

Effect.runFork(bll.run)
```
## 17.5 Layers
```ts
// Layer.ts
interface Layer<in ROut, out E = never, out RIn = never> {}
```
```ts
// https://effect.website/play/#6820e446f226
import { NodeRuntime } from "@effect/platform-node"
import { Chunk, Context, Data, Effect, Layer, Scope } from "effect"
import { DevToolsLive } from "./DevTools"

class Issue extends Data.Class {}
class Comment extends Issue {
  constructor(
    public readonly text: string
  ) {
    super()
  }
}
class BussinessLogicTag extends Context.Tag("BussinessLogicTag")<BussinessLogicTag, BussinessLogic>() {}
interface BussinessLogic {
  run: Effect.Effect<void>
}

class GitHubTag extends Context.Tag("GitHubTag")<GitHubTag, GitHub>() {}
interface GitHub {
  getIssues: (organization: string) => Effect.Effect<Chunk.Chunk<Issue>>
  postComment: (issue: Issue, comment: Comment) => Effect.Effect<void>
}

class HttpTag extends Context.Tag("HttpTag")<HttpTag, Http>() {}
interface Http {
  get: (url: string) => Effect.Effect<Chunk.Chunk<number>>
  post: (url: string, body: Chunk.Chunk<number>) => Effect.Effect<Chunk.Chunk<number>>
  start: Effect.Effect<void>
}

const BussinessLogicLive = (github: GitHub): BussinessLogic => ({
  run: Effect.gen(function*() {
    const issues = yield* github.getIssues("effect")
    const comment = new Comment("I am working on this!")
    yield* Effect.orDie(Chunk.head(issues))
      .pipe(Effect.flatMap((issue) => github.postComment(issue, comment)))
  })
})
const BussinessLogicLayerLive = Layer.function(
  GitHubTag,
  BussinessLogicTag,
  (github) => BussinessLogicLive(github)
)

const GitHubLive = (http: Http): GitHub => ({
  getIssues: () => "???" as any,
  postComment: () => "???" as any
})
const GitHubLayerLive = Layer.function(
  HttpTag,
  GitHubTag,
  (http) => GitHubLive(http)
)

const HttpLive = (): Http => ({
  get: () => "???" as any,
  post: () => "???" as any,
  start: "???" as any
})
const HttpLayerLive = Layer.effect(
  HttpTag,
  Effect.gen(function*() {
    const http = HttpLive()
    yield* http.start
    return http
  })
)

const http = HttpLive()
const github = GitHubLive(http)
const bll = BussinessLogicLive(github)

Effect.runFork(bll.run)
```